#!/usr/bin/env bash
set -euo pipefail

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$ROOT"

# Prefer native toolchains (Apple Silicon) and repo-local binaries.
ARM64_GO="$HOME/.local/arm64/go/bin/go"
ARM64_NODE_BIN="$HOME/.local/arm64/node/bin"

# 1) Prefer ~/.local/bin (arm64 uv, etc)
if [[ -d "$HOME/.local/bin" ]]; then
  export PATH="$HOME/.local/bin:$PATH"
fi
# 2) Prefer repo-local whisper.cpp builds
if [[ -d "$ROOT/.tools/whispercpp/bin" ]]; then
  export PATH="$ROOT/.tools/whispercpp/bin:$PATH"
fi
# 2b) Prefer vendored whisper.cpp dylibs if present.
if [[ -d "$ROOT/.tools/whispercpp/lib" ]]; then
  if [[ -n "${DYLD_FALLBACK_LIBRARY_PATH:-}" ]]; then
    export DYLD_FALLBACK_LIBRARY_PATH="$ROOT/.tools/whispercpp/lib:$DYLD_FALLBACK_LIBRARY_PATH"
  else
    export DYLD_FALLBACK_LIBRARY_PATH="$ROOT/.tools/whispercpp/lib"
  fi
fi
# 3) Prefer an arm64 node if present
if [[ -d "$ARM64_NODE_BIN" ]]; then
  export PATH="$ARM64_NODE_BIN:$PATH"
fi
# 4) Keep common Homebrew locations available, but do not let them override the above.
for d in /opt/homebrew/bin /usr/local/bin; do
  if [[ -d "$d" && ":$PATH:" != *":$d:"* ]]; then
    export PATH="$PATH:$d"
  fi
done

# Use the Samantha-tuned OpenClaw agent unless the user overrides it.
export OPENCLAW_AGENT_ID="${OPENCLAW_AGENT_ID:-samantha}"

# Load local env if present (do not commit .env).
if [[ -f "$ROOT/.env" ]]; then
  set -a
  # shellcheck disable=SC1091
  source "$ROOT/.env"
  set +a
fi

# OpenClaw Gateway (WS) is the fastest path for streaming assistant deltas.
# Generate a per-repo token once (gitignored) so `make dev` can start/connect
# without requiring manual config. Avoid clobbering a user-managed gateway token
# when a gateway is already running on the port.
gateway_port="18789"
gateway_listening=0
if command -v lsof >/dev/null 2>&1; then
  if lsof -nP -iTCP:"$gateway_port" -sTCP:LISTEN >/dev/null 2>&1; then
    gateway_listening=1
  fi
elif command -v nc >/dev/null 2>&1; then
  if nc -z 127.0.0.1 "$gateway_port" >/dev/null 2>&1; then
    gateway_listening=1
  fi
fi

if [[ -z "${OPENCLAW_GATEWAY_URL:-}" ]]; then
  export OPENCLAW_GATEWAY_URL="ws://127.0.0.1:18789"
fi

mkdir -p "$ROOT/.tmp" >/dev/null 2>&1 || true
gateway_pid_file="$ROOT/.tmp/openclaw_gateway.pid"
token_file="$ROOT/.tmp/openclaw_gateway_token"

if [[ -z "${OPENCLAW_GATEWAY_TOKEN:-}" ]]; then
  if [[ "$gateway_listening" == "0" ]]; then
    if [[ -f "$token_file" ]]; then
      export OPENCLAW_GATEWAY_TOKEN="$(cat "$token_file" 2>/dev/null || true)"
    fi
    if [[ -z "${OPENCLAW_GATEWAY_TOKEN:-}" ]]; then
      export OPENCLAW_GATEWAY_TOKEN="$(python3 -c 'import secrets; print(secrets.token_urlsafe(24))' 2>/dev/null || true)"
      echo -n "$OPENCLAW_GATEWAY_TOKEN" >"$token_file" 2>/dev/null || true
      chmod 600 "$token_file" >/dev/null 2>&1 || true
    fi
  else
    # Only auto-load the token when the gateway was started by this script (pid file present).
    if [[ -f "$gateway_pid_file" ]]; then
      pid="$(cat "$gateway_pid_file" 2>/dev/null || true)"
      if [[ -n "$pid" ]] && ps -p "$pid" >/dev/null 2>&1; then
        if [[ -f "$token_file" ]]; then
          export OPENCLAW_GATEWAY_TOKEN="$(cat "$token_file" 2>/dev/null || true)"
        fi
      fi
    fi
  fi
fi

AUTH_MAIN="$HOME/.openclaw/agents/main/agent/auth-profiles.json"
AUTH_SAM="$HOME/.openclaw/agents/${OPENCLAW_AGENT_ID}/agent/auth-profiles.json"

# Only sync Codex tokens into OpenClaw when the auth profile is missing.
if [[ ! -f "$AUTH_MAIN" ]] || ! grep -q '"openai-codex:default"' "$AUTH_MAIN" 2>/dev/null; then
  python3 "$ROOT/scripts/openclaw_bootstrap_from_codex.py" >/dev/null 2>&1 || true
fi

# Ensure the selected OpenClaw agent exists (non-interactive).
if command -v openclaw >/dev/null 2>&1; then
  AGENT_ID="${OPENCLAW_AGENT_ID:-samantha}"
  WORKSPACE_EXPLICIT=0
  if [[ -n "${OPENCLAW_WORKSPACE_DIR:-}" ]]; then
    WORKSPACE_EXPLICIT=1
  fi
  # Mutable OpenClaw scratch (downloaded repos, web scrapes, tool outputs) must not live in the git repo.
  # Keep the repo directory as a template only, and sync it into a per-user workspace.
  WORKSPACE_DIR="${OPENCLAW_WORKSPACE_DIR:-$HOME/.openclaw/workspaces/$AGENT_ID}"
  if [[ "$WORKSPACE_DIR" != /* ]]; then
    WORKSPACE_DIR="$ROOT/$WORKSPACE_DIR"
  fi

  TEMPLATE_DIR="$ROOT/openclaw/samantha-workspace"
  sync_workspace_template() {
    local workspace="$1"
    mkdir -p "$workspace" >/dev/null 2>&1 || true
    for f in AGENTS.md HEARTBEAT.md IDENTITY.md SOUL.md TOOLS.md USER.md; do
      if [[ -f "$TEMPLATE_DIR/$f" ]]; then
        cp -f "$TEMPLATE_DIR/$f" "$workspace/$f" >/dev/null 2>&1 || true
      fi
    done
  }

  agents_json="$(openclaw agents list --json 2>/dev/null || true)"
  agent_info="$(AGENTS_JSON="$agents_json" python3 -c 'import json,os,sys
aid=sys.argv[1]
raw=os.environ.get("AGENTS_JSON","")
exists="0"
ws=""
try:
  arr=json.loads(raw) if raw else []
except Exception:
  arr=[]
for a in arr:
  if a.get("id")==aid:
    exists="1"
    ws=str(a.get("workspace","") or "")
    break
print(f"{exists}|{ws.strip()}")' "$AGENT_ID" 2>/dev/null || echo "0|")"
  agent_exists="${agent_info%%|*}"
  existing_workspace="${agent_info#*|}"

  if [[ "$agent_exists" == "1" ]]; then

    if [[ -z "$existing_workspace" ]]; then
      echo "OpenClaw agent '$AGENT_ID' exists but its workspace path could not be determined." >&2
      echo "Fix it by pointing Samantha at the existing workspace or choosing a new agent id." >&2
      echo "" >&2
      echo "  openclaw agents list --json" >&2
      echo "  export OPENCLAW_AGENT_ID=\"$AGENT_ID\"" >&2
      echo "  export OPENCLAW_WORKSPACE_DIR=\"...\"" >&2
      exit 1
    fi

    desired_real="$(python3 -c 'import os,sys; print(os.path.realpath(sys.argv[1]))' "$WORKSPACE_DIR" 2>/dev/null || echo "$WORKSPACE_DIR")"
    existing_real="$(python3 -c 'import os,sys; print(os.path.realpath(sys.argv[1]))' "$existing_workspace" 2>/dev/null || echo "$existing_workspace")"
    if [[ "$existing_real" != "$desired_real" ]]; then
      if [[ "$WORKSPACE_EXPLICIT" == "1" ]]; then
        echo "OpenClaw agent '$AGENT_ID' workspace mismatch:" >&2
        echo "  configured: $existing_workspace" >&2
        echo "  expected:   $WORKSPACE_DIR" >&2
        echo "" >&2
        echo "To fix (non-destructive options first):" >&2
        echo "  1) Keep using the configured workspace (fastest):" >&2
        echo "     export OPENCLAW_WORKSPACE_DIR=\"$existing_workspace\"" >&2
        echo "  2) Use a different agent id for this repo (keeps your existing agent state intact):" >&2
        echo "     export OPENCLAW_AGENT_ID=\"${AGENT_ID}-$(date +%s)\"" >&2
        echo "  3) If you want to migrate the existing agent without losing sessions/state:" >&2
        echo "     update the agent workspace path in ~/.openclaw/openclaw.json" >&2
        echo "  4) Last resort (destructive): delete + recreate the agent:" >&2
        echo "     openclaw agents delete $AGENT_ID" >&2
        exit 1
      fi
      echo "OpenClaw agent '$AGENT_ID' already uses workspace '$existing_workspace'; reusing it." >&2
      WORKSPACE_DIR="$existing_workspace"
    fi
  else
    if ! openclaw agents add "$AGENT_ID" \
      --non-interactive \
      --workspace "$WORKSPACE_DIR" \
      --model openai-codex/gpt-5.3-codex \
      --json >/dev/null 2>&1; then
      echo "Note: failed to create OpenClaw agent '$AGENT_ID' (continuing with mock brain if needed)." >&2
    fi
  fi

  sync_workspace_template "$WORKSPACE_DIR"

  if [[ -f "$AUTH_MAIN" && ! -f "$AUTH_SAM" ]]; then
    mkdir -p "$(dirname "$AUTH_SAM")" || true
    cp -f "$AUTH_MAIN" "$AUTH_SAM" || true
    chmod 600 "$AUTH_SAM" >/dev/null 2>&1 || true
  fi
fi

# Start the OpenClaw Gateway on loopback if it's not already listening.
# This enables the WS adapter (streaming) and avoids the non-streaming CLI path.
if command -v openclaw >/dev/null 2>&1; then
  if [[ "$gateway_listening" == "0" && -n "${OPENCLAW_GATEWAY_TOKEN:-}" ]]; then
    (
      export OPENCLAW_GATEWAY_TOKEN="$OPENCLAW_GATEWAY_TOKEN"
      export OPENCLAW_GATEWAY_URL="$OPENCLAW_GATEWAY_URL"
      openclaw gateway --allow-unconfigured --bind loopback --port "$gateway_port" \
        >"$ROOT/.tmp/openclaw_gateway.log" 2>&1
    ) &
    echo $! >"$gateway_pid_file" 2>/dev/null || true
  fi
fi

VOICE_PROVIDER_LOWER="$(echo "${VOICE_PROVIDER:-local}" | tr '[:upper:]' '[:lower:]' | tr -d ' ')"

if [[ "$VOICE_PROVIDER_LOWER" == "elevenlabs" && -z "${ELEVENLABS_API_KEY:-}" ]]; then
  echo "Note: VOICE_PROVIDER=elevenlabs but ELEVENLABS_API_KEY is not set (server will fail to start)." >&2
fi

# Auto mode can use local fallback when ElevenLabs fails.
if [[ "$VOICE_PROVIDER_LOWER" == "auto" && -z "${ELEVENLABS_API_KEY:-}" ]]; then
  echo "Note: ELEVENLABS_API_KEY is not set; VOICE_PROVIDER=auto will try local voice, then mock." >&2
fi

needs_local_voice=0
if [[ "$VOICE_PROVIDER_LOWER" == "local" ]]; then
  needs_local_voice=1
fi
if [[ "$VOICE_PROVIDER_LOWER" == "auto" ]]; then
  needs_local_voice=1
fi

whisper_tool_healthy() {
  local tool_path="$1"
  if [[ -z "$tool_path" || ! -x "$tool_path" ]]; then
    return 1
  fi
  if ! file "$tool_path" 2>/dev/null | grep -q 'arm64'; then
    return 1
  fi
  if command -v otool >/dev/null 2>&1; then
    if otool -l "$tool_path" 2>/dev/null | grep -Fq "$ROOT/.tools/build/"; then
      return 1
    fi
  fi
  local err
  err="$("$tool_path" --help 2>&1 >/dev/null || true)"
  if echo "$err" | grep -Eiq 'dyld|library not loaded|image not found'; then
    return 1
  fi
  return 0
}

if [[ "$needs_local_voice" == "1" ]]; then
  need_setup=0

  # Prefer repo-local arm64 whisper.cpp tools and ensure they are runtime-loadable.
  whisper_cli_path=""
  whisper_server_path=""
  if command -v whisper-cli >/dev/null 2>&1; then
    whisper_cli_path="$(command -v whisper-cli)"
  fi
  if command -v whisper-server >/dev/null 2>&1; then
    whisper_server_path="$(command -v whisper-server)"
  fi

  if ! whisper_tool_healthy "$whisper_cli_path"; then
    need_setup=1
  fi
  if ! whisper_tool_healthy "$whisper_server_path"; then
    need_setup=1
  fi

  if [[ ! -x "$ROOT/.venv/bin/python3" && ! -x "$ROOT/.venv/bin/python" ]]; then
    need_setup=1
  else
    py_check="$ROOT/.venv/bin/python"
    if [[ -x "$ROOT/.venv/bin/python3" ]]; then
      py_check="$ROOT/.venv/bin/python3"
    fi
    if ! arch -arm64 "$py_check" -c 'import platform, numpy; print(platform.machine())' 2>/dev/null | grep -q '^arm64'; then
      need_setup=1
    fi
  fi

  if [[ "${LOCAL_WHISPER_MODEL_PATH:-.models/whisper/ggml-tiny.en.bin}" != /* ]]; then
    model_path="$ROOT/${LOCAL_WHISPER_MODEL_PATH:-.models/whisper/ggml-tiny.en.bin}"
  else
    model_path="${LOCAL_WHISPER_MODEL_PATH:-.models/whisper/ggml-tiny.en.bin}"
  fi
  if [[ ! -f "$model_path" ]]; then
    need_setup=1
  fi

  if [[ "$need_setup" == "1" ]]; then
    echo "Bootstrapping local voice (whisper.cpp + kokoro). This may take a few minutes on first run..." >&2
    if ! "$ROOT/scripts/setup_local_voice.sh"; then
      if [[ "$VOICE_PROVIDER_LOWER" == "local" ]]; then
        echo "Local voice setup failed. Fix the errors above, then rerun: make dev" >&2
        exit 1
      fi
      echo "Local voice setup failed; continuing (VOICE_PROVIDER=$VOICE_PROVIDER_LOWER)." >&2
    fi
  fi
fi

if lsof -iTCP:8080 -sTCP:LISTEN -n -P >/dev/null 2>&1; then
  pid="$(lsof -iTCP:8080 -sTCP:LISTEN -n -P -t | head -n 1 || true)"
  if [[ -n "${pid:-}" ]]; then
    cmd="$(ps -p "$pid" -o args= 2>/dev/null || true)"
    # Common cases:
    # - `go run ./cmd/samantha` -> temp binary under $TMPDIR/go-build.../exe/samantha
    # - `bin/samantha`
    if [[ "$cmd" == *"/go-build"*"exe/samantha"* || "$cmd" == *"cmd/samantha"* || "$cmd" == *"bin/samantha"* || "$cmd" == *"samantha-companion"* ]]; then
      kill "$pid" >/dev/null 2>&1 || true
      sleep 0.4
    fi
  fi
fi

echo "UI: http://127.0.0.1:8080/ui/  (add ?onboarding=1 to rerun first-run checks)" >&2

if [[ -x "$ARM64_GO" ]]; then
  exec arch -arm64 "$ARM64_GO" run ./cmd/samantha
fi

exec go run ./cmd/samantha
